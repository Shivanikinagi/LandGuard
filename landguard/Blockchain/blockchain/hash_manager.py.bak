"""
LandGuard Cryptographic Hash Manager
SHA-256 hashing for evidence integrity and tamper detection
"""

import hashlib
import json
from typing import Dict, List, Any, Union
from pathlib import Path
from datetime import datetime, timezone
import base64


class HashManager:
    """Manage cryptographic hashing for evidence integrity"""
    
    def __init__(self, storage_dir: str = 'blockchain/storage/hashes'):
        self.storage_dir = Path(storage_dir)
        self.storage_dir.mkdir(parents=True, exist_ok=True)
        self.algorithm = 'sha256'
    
    def hash_data(self, data: Union[str, bytes, Dict]) -> str:
        """
        Generate SHA-256 hash of data
        
        Args:
            data: String, bytes, or dictionary to hash
        
        Returns:
            Hexadecimal hash string
        """
        # Convert to bytes
        if isinstance(data, dict):
            # Sort keys for consistent hashing
            data_str = json.dumps(data, sort_keys=True, ensure_ascii=False)
            data_bytes = data_str.encode('utf-8')
        elif isinstance(data, str):
            data_bytes = data.encode('utf-8')
        else:
            data_bytes = data
        
        # Generate hash
        hash_obj = hashlib.sha256(data_bytes)
        return hash_obj.hexdigest()
    
    def hash_file(self, file_path: str) -> str:
        """
        Generate SHA-256 hash of a file
        
        Args:
            file_path: Path to file
        
        Returns:
            Hexadecimal hash string
        """
        hash_obj = hashlib.sha256()
        
        with open(file_path, 'rb') as f:
            # Read file in chunks to handle large files
            while chunk := f.read(8192):
                hash_obj.update(chunk)
        
        return hash_obj.hexdigest()
    
    def hash_analysis_result(self, analysis_result: Dict) -> str:
        """
        Generate hash of fraud analysis result
        
        Args:
            analysis_result: Complete analysis result dictionary
        
        Returns:
            Evidence hash
        """
        # Extract key fields for hashing
        evidence_data = {
            'record_id': analysis_result.get('record_id'),
            'timestamp': analysis_result.get('timestamp'),
            'is_fraudulent': analysis_result.get('final_verdict', {}).get('is_fraudulent'),
            'risk_score': analysis_result.get('risk_assessment', {}).get('risk_score'),
            'ml_predictions': analysis_result.get('ml_predictions', {}),
            'rule_violations': analysis_result.get('rule_violations', [])
        }
        
        return self.hash_data(evidence_data)
    
    def verify_data(self, data: Union[str, bytes, Dict], 
                   expected_hash: str) -> bool:
        """
        Verify data integrity against expected hash
        
        Args:
            data: Data to verify
            expected_hash: Expected hash value
        
        Returns:
            True if hash matches, False otherwise
        """
        actual_hash = self.hash_data(data)
        return actual_hash == expected_hash
    
    def verify_file(self, file_path: str, expected_hash: str) -> bool:
        """Verify file integrity"""
        actual_hash = self.hash_file(file_path)
        return actual_hash == expected_hash
    
    def create_evidence_hash_chain(self, 
                                   evidence_list: List[Dict]) -> Dict[str, Any]:
        """
        Create a hash chain for multiple evidence items
        
        Args:
            evidence_list: List of evidence dictionaries
        
        Returns:
            Hash chain with root hash
        """
        if not evidence_list:
            return {'root_hash': None, 'chain': []}
        
        chain = []
        previous_hash = None
        
        for evidence in evidence_list:
            # Create evidence entry
            entry = {
                'evidence': evidence,
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'previous_hash': previous_hash
            }
            
            # Hash this entry
            entry_hash = self.hash_data(entry)
            entry['hash'] = entry_hash
            
            chain.append(entry)
            previous_hash = entry_hash
        
        # Root hash is hash of all hashes
        all_hashes = [e['hash'] for e in chain]
        root_hash = self.hash_data(''.join(all_hashes))
        
        return {
            'root_hash': root_hash,
            'chain': chain,
            'length': len(chain),
            'created_at': datetime.now(timezone.utc).isoformat()
        }
    
    def verify_hash_chain(self, hash_chain: Dict) -> bool:
        """
        Verify integrity of entire hash chain
        
        Args:
            hash_chain: Hash chain dictionary
        
        Returns:
            True if chain is valid
        """
        chain = hash_chain.get('chain', [])
        expected_root = hash_chain.get('root_hash')
        
        if not chain:
            return expected_root is None
        
        # Verify each link
        previous_hash = None
        for entry in chain:
            # Check previous hash matches
            if entry['previous_hash'] != previous_hash:
                return False
            
            # Recalculate entry hash
            entry_copy = entry.copy()
            stored_hash = entry_copy.pop('hash')
            
            calculated_hash = self.hash_data(entry_copy)
            if calculated_hash != stored_hash:
                return False
            
            previous_hash = stored_hash
        
        # Verify root hash
        all_hashes = [e['hash'] for e in chain]
        calculated_root = self.hash_data(''.join(all_hashes))
        
        return calculated_root == expected_root
    
    def save_hash_record(self, record_id: str, hash_value: str, 
                        metadata: Dict = None):
        """
        Save hash record to storage
        
        Args:
            record_id: Unique identifier
            hash_value: Hash to store
            metadata: Additional metadata
        """

        record = {
            'record_id': record_id,
            'hash': hash_value,
            'algorithm': self.algorithm,
            'created_at': datetime.now(timezone.utc).isoformat(),
            'metadata': metadata or {}
        }
        
        file_path = self.storage_dir / f"{record_id}.json"
        with open(file_path, 'w') as f:
            json.dump(record, f, indent=2)
    
    def load_hash_record(self, record_id: str) -> Dict:
        """Load hash record from storage"""
        file_path = self.storage_dir / f"{record_id}.json"
        
        if not file_path.exists():
            raise FileNotFoundError(f"Hash record not found: {record_id}")
        
        with open(file_path, 'r') as f:
            return json.load(f)
    
    def generate_content_id(self, data: Union[str, bytes, Dict]) -> str:
        """
        Generate content-addressable ID (similar to IPFS CID)
        
        Args:
            data: Content to generate ID for
        
        Returns:
            Base58-encoded hash (CID-like)
        """
        hash_bytes = hashlib.sha256(
            self.hash_data(data).encode()
        ).digest()
        
        # Simplified base58 encoding (for demo)
        # In production, use proper base58 library
        return base64.urlsafe_b64encode(hash_bytes).decode().rstrip('=')


class EvidenceIntegrityChecker:
    """Check evidence integrity and detect tampering"""
    
    def __init__(self, hash_manager: HashManager = None):
        self.hash_manager = hash_manager or HashManager()
    
    def check_evidence(self, evidence: Dict, 
                      expected_hash: str) -> Dict[str, Any]:
        """
        Comprehensive evidence integrity check
        
        Args:
            evidence: Evidence dictionary
            expected_hash: Expected hash value
        
        Returns:
            Integrity check result
        """
        # Calculate actual hash
        actual_hash = self.hash_manager.hash_data(evidence)
        
        # Check if matches
        is_valid = actual_hash == expected_hash
        
        result = {
            'is_valid': is_valid,
            'expected_hash': expected_hash,
            'actual_hash': actual_hash,
            'checked_at': datetime.now(timezone.utc).isoformat(),
            'status': 'VERIFIED' if is_valid else 'TAMPERED'
        }
        
        if not is_valid:
            result['warning'] = '‚ö†Ô∏è  Evidence has been tampered with!'
            result['recommendation'] = 'DO NOT USE - Evidence integrity compromised'
        
        return result
    
    def batch_verify(self, evidence_list: List[Dict], 
                    hash_chain: Dict) -> Dict[str, Any]:
        """
        Verify multiple evidence items using hash chain
        
        Args:
            evidence_list: List of evidence items
            hash_chain: Hash chain to verify against
        
        Returns:
            Batch verification result
        """
        # First verify the hash chain itself
        chain_valid = self.hash_manager.verify_hash_chain(hash_chain)
        
        if not chain_valid:
            return {
                'is_valid': False,
                'chain_valid': False,
                'message': 'Hash chain is corrupted',
                'recommendation': 'CRITICAL: Evidence chain compromised'
            }
        
        # Verify each evidence item
        chain_entries = hash_chain.get('chain', [])
        results = []
        
        for i, (evidence, entry) in enumerate(zip(evidence_list, chain_entries)):
            # Check if evidence matches chain entry
            entry_evidence = entry.get('evidence')
            evidence_hash = self.hash_manager.hash_data(evidence)
            entry_hash = self.hash_manager.hash_data(entry_evidence)
            
            is_match = evidence_hash == entry_hash
            
            results.append({
                'index': i,
                'is_valid': is_match,
                'evidence_hash': evidence_hash,
                'chain_hash': entry_hash
            })
        
        all_valid = all(r['is_valid'] for r in results)
        
        return {
            'is_valid': all_valid and chain_valid,
            'chain_valid': chain_valid,
            'individual_results': results,
            'total_items': len(evidence_list),
            'valid_items': sum(1 for r in results if r['is_valid']),
            'verified_at': datetime.now(timezone.utc).isoformat()
        }


# Example usage
if __name__ == "__main__":
    print("üîê LandGuard Hash Manager Demo\n")
    
    # Initialize hash manager
    hash_mgr = HashManager()
    
    # Example 1: Hash analysis result
    print("1Ô∏è‚É£ Hashing Analysis Result")
    print("‚îÄ" * 60)
    
    analysis_result = {
        'record_id': 'LAND_001',
        'timestamp': '2024-11-25T10:30:00Z',
        'final_verdict': {
            'is_fraudulent': True,
            'confidence': 0.92
        },
        'risk_assessment': {
            'risk_score': 87.5
        }
    }
    
    evidence_hash = hash_mgr.hash_analysis_result(analysis_result)
    print(f"Evidence Hash: {evidence_hash}")
    print(f"Length: {len(evidence_hash)} characters\n")
    
    # Example 2: Verify data integrity
    print("2Ô∏è‚É£ Verifying Data Integrity")
    print("‚îÄ" * 60)
    
    is_valid = hash_mgr.verify_data(analysis_result, evidence_hash)
    print(f"‚úÖ Original data valid: {is_valid}")
    
    # Tamper with data
    tampered_result = analysis_result.copy()
    tampered_result['risk_assessment']['risk_score'] = 10.0  # Changed!
    
    is_valid = hash_mgr.verify_data(tampered_result, evidence_hash)
    print(f"‚ùå Tampered data valid: {is_valid}\n")
    
    # Example 3: Hash chain
    print("3Ô∏è‚É£ Creating Hash Chain")
    print("‚îÄ" * 60)
    
    evidence_items = [
        {'case_id': 'CASE_001', 'fraud_score': 85},
        {'case_id': 'CASE_002', 'fraud_score': 12},
        {'case_id': 'CASE_003', 'fraud_score': 67}
    ]
    
    hash_chain = hash_mgr.create_evidence_hash_chain(evidence_items)
    print(f"Root Hash: {hash_chain['root_hash']}")
    print(f"Chain Length: {hash_chain['length']}")
    print(f"Created: {hash_chain['created_at']}\n")
    
    # Example 4: Verify hash chain
    print("4Ô∏è‚É£ Verifying Hash Chain")
    print("‚îÄ" * 60)
    
    checker = EvidenceIntegrityChecker(hash_mgr)
    
    # Valid chain
    is_chain_valid = hash_mgr.verify_hash_chain(hash_chain)
    print(f"‚úÖ Original chain valid: {is_chain_valid}")
    
    # Tamper with chain
    tampered_chain = hash_chain.copy()
    tampered_chain['chain'][1]['evidence']['fraud_score'] = 99
    
    is_chain_valid = hash_mgr.verify_hash_chain(tampered_chain)
    print(f"‚ùå Tampered chain valid: {is_chain_valid}\n")
    
    # Example 5: Batch verification
    print("5Ô∏è‚É£ Batch Evidence Verification")
    print("‚îÄ" * 60)
    
    batch_result = checker.batch_verify(evidence_items, hash_chain)
    print(f"All Valid: {batch_result['is_valid']}")
    print(f"Chain Valid: {batch_result['chain_valid']}")
    print(f"Valid Items: {batch_result['valid_items']}/{batch_result['total_items']}")
    
    # Example 6: Content-addressable ID
    print("\n6Ô∏è‚É£ Content-Addressable ID (CID)")
    print("‚îÄ" * 60)
    
    cid = hash_mgr.generate_content_id(analysis_result)
    print(f"Content ID: {cid}")
    print(f"Length: {len(cid)} characters")
    
    # Same content = same ID
    cid2 = hash_mgr.generate_content_id(analysis_result)
    print(f"Deterministic: {cid == cid2}")
    
    print("\n‚úÖ Hash Manager Demo Complete!")